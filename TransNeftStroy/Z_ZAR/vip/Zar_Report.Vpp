//by ABSOLUTO
//==============================
window wnReport 'Отчет';
//--------------------------------------------------------------------------------
//-------------------------'Первая панель (группы)'-------------------------------

Tree trTmpTree('Ctrl+P - Печать всего отчета, Alt+P - Печать с текущего уровня',, sci1EscTree);
  Show at (,,, 10);
  Table TempDescr;

Fields

  TempDescr.Name    'Наименование'    ('Наименование',,)
                    : [50], Protect;

  TempDescr.Sum[3]  'Среднесписочная численность' ('Явочные дни',,)
                    : [16.2,'\2p[|-]366`666`666`666.88'], Skip;
  TempDescr.Sum[6]  'Отработано дней'    ('Явочные дни',,)
                    : [16.2,'\2p[|-]366`666`666`666.88'], Skip;

  Calc_Neyavki 'Всего неявок'    ('Оплачено',,)
                    : [16.2,'\2p[|-]366`666`666`666.88'], Skip;
end;
Screen scrRep01;
  show at (,11,,);
  Table TempDescr;
Fields
//1 -"№ п/п"	
//2 -"Вид деятельности/категория персонала"	
//3 -Среднесписочная численность
	
//4- Календарный фонд времени
//5- Максимально возможный фонд времени	
//6- Отработано дней	Всего:
//7- в том числе: отработано в выходные  и праздничные дни
//8 === Неявки по уважительным причинам	8 Итого: 						
// из них:
// 9 Отпуск Всего:
//--в том числе:
//10 ежегодный очередной (основной), за работу в районах Крайнего Севера
//   и приравненных к нему местностях, в районах подвергшихся радиации (Чернобыль), Дальний Восток и т.д.
//11 дополнительный отпуск за ненорм. раб. день, за вредн.условия труда и т.д.
//12 социальный (на похороны, день знаний и т.д.) 
//----
//13 отпуск в связи с обучением
//14 повышение квалификации
//15 время проезда к месту использования отпуска
//16 выходные и праздничные дни
//17 Дни нетрудоспособности  Всего:
//---- в том числе:
//18 по болезни работника, уходу за больными
//19 при производственных, бытовых травмах
//----
//20 прочие неявки, разрешенные законом (донорские, гособязанность и др.)
//21 == Потери рабочего времени Всего:
//22 отпуск без сохранения заработной платы
//23 неявки из-за привлечения к ответственности
//24 прогулы
//25 целодневные внутрисменные простои 
//26 неявки по невыясненным причинам
//27 === Отработано часов Всего:
//--- в том числе:
//28 в урочное время
//29 в праздничные и выходные дни, объявленные адм. рабочим днем
//30 в сверхурочное время




TempDescr.Sum[03]: [12.2,'\2p[|-]366`666`666.88'], protect;//3-Среднесписочная численность
TempDescr.Sum[04]: [12.2,'\2p[|-]366`666`666.88'], protect;//4- Календарный фонд времени	
TempDescr.Sum[05]: [12.2,'\2p[|-]366`666`666.88'], protect;//5- Максимально возможный фонд времени	
TempDescr.Sum[06]: [12.2,'\2p[|-]366`666`666.88'], protect;//6- Отработано дней	Всего:	
TempDescr.Sum[07]: [12.2,'\2p[|-]366`666`666.88'], protect;//7- в том числе: отработано в выходные  и праздничные дни
TempDescr.Sum[08]: [12.2,'\2p[|-]366`666`666.88'], protect;//8 === Неявки по уважительным причинам	8 Итого: 						
// из них:										
TempDescr.Sum[09]: [12.2,'\2p[|-]366`666`666.88'], protect;// 9 Отпуск Всего:
//--в том числе:		
TempDescr.Sum[10]: [12.2,'\2p[|-]366`666`666.88'], protect;//10 ежегодный очередной (основной), за работу в районах Крайгего Севера
//   и приравненных к нему местностях, в районах подвергшихся радиации (Чернобыль), Дальний Восток и т.д.
TempDescr.Sum[11]: [12.2,'\2p[|-]366`666`666.88'], protect;//11 дополнительный отпуск за ненорм. раб. день, за вредн.условия труда и т.д.
TempDescr.Sum[12]: [12.2,'\2p[|-]366`666`666.88'], protect;//12 социальный (на похороны, день знаний и т.д.) 
//----
TempDescr.Sum[13]: [12.2,'\2p[|-]366`666`666.88'], protect;//13 отпуск в связи с обучением
TempDescr.Sum[14]: [12.2,'\2p[|-]366`666`666.88'], protect;//14 повышение квалификации
TempDescr.Sum[15]: [12.2,'\2p[|-]366`666`666.88'], protect;//15 время проезда к месту использования отпуска
TempDescr.Sum[16]: [12.2,'\2p[|-]366`666`666.88'], protect;//16 выходные и праздничные дни
TempDescr.Sum[17]: [12.2,'\2p[|-]366`666`666.88'], protect;//17 Дни нетрудоспособности		Всего:
//---- в том числе:	
TempDescr.Sum[18]: [12.2,'\2p[|-]366`666`666.88'], protect;//18 по болезни работника, уходу за больными
TempDescr.Sum[19]: [12.2,'\2p[|-]366`666`666.88'], protect;//19 при производственных, бытовых травмах
//----
TempDescr.Sum[20]: [12.2,'\2p[|-]366`666`666.88'], protect;//20 прочие неявки, разрешенные законом (донорские, гособязанность и др.)
TempDescr.Sum[21]: [12.2,'\2p[|-]366`666`666.88'], protect;//21 == Потери рабочего времени Всего:
TempDescr.Sum[22]: [12.2,'\2p[|-]366`666`666.88'], protect;//22 отпуск без сохранения заработной платы
TempDescr.Sum[23]: [12.2,'\2p[|-]366`666`666.88'], protect;//23 неявки из-за привлечения к ответственности
TempDescr.Sum[24]: [12.2,'\2p[|-]366`666`666.88'], protect;//24 прогулы
TempDescr.Sum[25]: [12.2,'\2p[|-]366`666`666.88'], protect;//25 целодневные внутрисменные простои 
TempDescr.Sum[26]: [12.2,'\2p[|-]366`666`666.88'], protect;//26 неявки по невыясненным причинам
TempDescr.Sum[27]: [12.2,'\2p[|-]366`666`666.88'], protect;//27 === Отработано часов Всего:
//--- в том числе:		
TempDescr.Sum[28]: [12.2,'\2p[|-]366`666`666.88'], protect;//28 в урочное время
TempDescr.Sum[29]: [12.2,'\2p[|-]366`666`666.88'], protect;//29 в праздничные и выходные дни, объявленные адм. рабочим днем
TempDescr.Sum[20]: [12.2,'\2p[|-]366`666`666.88'], protect;//30 в сверхурочное время

<<                
`Среднесписочная численность` .@@@@@@@ 
`Календарный фонд времени   ` .@@@@@@@ `Максимально возможный фонд времени`   .@@@@@@@	
`Отработано дней   Всего:   ` .@@@@@@@ в том числе: отработано в выходные и праздничные дни .@@@@@@
`Неявки по уважительным причинам Итого:` .@@@@@@@
 из них:
 `Отпуск Всего:`   .@@@@@@@ 
 в том числе:
 ежегодный очередной (основной), за работу в районах Крайнего Севера         .@@@@@@@
 и приравненных к нему местностях, в районах подвергшихся радиации (Чернобыль), Дальний Восток и т.д.
 дополнительный отпуск за ненорм. раб. день, за вредн.условия труда и т.д.   .@@@@@@@
 социальный (на похороны, день знаний и т.д.)                                .@@@@@@@
 -----------------------------------------
 отпуск в связи с обучением   .@@@@@@@  повышение квалификации   .@@@@@@@
 время проезда к месту использования отпуска .@@@@@@@
 выходные и праздничные дни                  .@@@@@@@
 -----------------------------------------
 Дни нетрудоспособности Всего:  .@@@@@@@ 
 в том числе:
 по болезни работника, уходу за больными.@@@@@@@ при производственных, бытовых травмах .@@@@@@@
 -------------------------
 прочие неявки, разрешенные законом (донорские, гособязанность и др.)                  .@@@@@@@
 ---------------------------------------
 `Потери рабочего времени Всего:`       .@@@@@@@
 отпуск без сохранения заработной платы .@@@@@@@ неявки из-за привлечения к ответственности.@@@@@@@
 прогулы                                .@@@@@@@ целодневные внутрисменные простои         .@@@@@@@
 неявки по невыясненным причинам        .@@@@@@@ 
 ---------------------------------------
 `Отработано часов Всего:`              .@@@@@@@
 в том числе:
 в урочное время      .@@@@@@@ в праздничные и выходные дни, объявленные адм. рабочим днем .@@@@@@@
 в сверхурочное время .@@@@@@@
>>
end;
HandleEvent
cmHotKeys:
{ PutCommand(RunMenu('mnFZ21_Print')) ;
}
cmValue2: PrintDoc_00(2);
cmPrintDoc: 
{ PrintDoc_00(0);
}
cmPlansNo:
{ PrintDoc_00(1);
}
end; //HandleEvent
end; //window wnReport  'Отчет;


//==============================
// Установить отладку
//==============================
Procedure SetLogFile (w :string) ;
{ 
  if w<>''
  {  logfilenm:=w ;
     logfilekl:=true ;
  }
  else
   logfilekl:=false ;
  
}


//===================================
// проверить на применимость DSQL
//===================================
Function CheckUseDsql:boolean;
{
  Result := false;

  case GetDbPlatformType of
    dbptOracle:
     Result := true;
    3: //MSSQL
     Result := true;
  end;

//  UseDsql := GetBooleanParameter('DSQL', 'USEINTXO', 0);

} 

//==============================
// Перегон из PickRep в Marker
//==============================
Procedure PickRep2MarkerVidopl (mrkName : string; wList : word; cRescomp : comp;
 mark1 :word; mark2:word;mark3:word
);
// cRescomp = 0 если множ.выбор и <> 0 если единичный
var
  cMarker : longint;
{
  cMarker := InitMarker(mrkName, mark1 , mark2,mark3);

  ClearMarker(cMarker);

  if ( cRescomp = 0 )
    {
      _LOOP PickRep noVisual where (( UserName         == PickRep.OwnName      and
                                      UserDeskRep.nRec == PickRep.cUserDeskRep and
                                      wList            == PickRep.wList ))
        InsertMarker(cMarker, PickRep.cRec);
    }
  else
    InsertMarker(cMarker, cRescomp);

  DoneMarker(cMarker, mrkName);
}

//=========================================================================
// Перегон из Marker'а в PickRep
//=========================================================================
Procedure Marker2PickRepVidopl(mrkName : string; wList : word; var cRescomp : comp; var NumPick : word;
  mark1 :word; mark2:word;mark3:word
);
var
  cMarker, i, cCount : longint;
  PickRec            : word;
{
  cMarker := InitMarker(mrkName, mark1 , mark2,mark3);
  NumPick := 0;
  cCount  := GetMarkerCount(cMarker);

  FOR(i := 0; i < cCount; i++)
    if GetMarker(cMarker, i, PickRec)
      { //message(PickRec)
        ClearBuffer(#PickRep);

        PickRep.OwnName      := UserName;
        PickRep.wList        := wList;
        PickRep.cRec         := PickRec;
        PickRep.PickNum      := i;
        PickRep.cUserDeskRep := UserDeskRep.nRec;

        if ( insert current PickRep = tsOk )
          NumPick++;
      }

  if ( NumPick = 1 )
    {
      set cRescomp := PickRep.cRec;
      DelPickRep(wList);
    }
  else
    set cRescomp := 0;

  DoneMarker(cMarker, mrkName);
}

 
//=========================================================================
//'Чистка TmpKatalog
//=========================================================================
Function TmpKatalog_Delete : Boolean;
{
  TmpKatalog_Delete := True;

  if ( Delete All TmpKatalog = tsOk )
    RereadRecord(tnTmpKatalog)
  else
  {
    TmpKatalog_Delete := False
    Message(''#3'Ошибка удаления в таблице TmpKatalog.', Error);
  }
}


//=====================================
// Получить наименование уровня
//=====================================
Function Analitik_Name(ww_tbl :word) :string;
{ Analitik_Name:='';
  if getfirst katkau where (( ww_tbl == katkau.kodgroup ))=0
    Analitik_Name:=katkau.CODE+'('+string(katkau.kodgroup)+')'
}

// получить подразделение из доаналитики
Function OtpDOP_FindCex(ww_cex:comp; ww_dop:comp) :comp;
var 
 ii:word;
{ Result:=ww_cex
  if ww_dop=0 then exit;
  vOTPDOP.ww_otpdop:=WW_DOP;
  if VoTPdOP.getfirst OtpDop<>0 then exit;
  for(ii:=1;ii<=6;ii++)
  { if vOTPDOP.OtpDop.tbld[ii]=2 and vOTPDOP.OtpDop.cKaud[ii]>0
    { Result := vOTPDOP.OtpDop.cKaud[ii]
      exit;
    } 
  }
}


//==========================================
Function GetNameSpr(ww_tp:word;ww_tbl:word;ww_crec:comp;ww_crec1:comp=0):string;
var 
  ww_str,ww_str1:string;
  ww_nrec:comp;
{ if (getfirst tmp_spr where (( ww_tp == tmp_spr.tp and ww_tbl == tmp_spr.tbl
     and ww_crec == tmp_spr.crec 
     and ww_crec1 == tmp_spr.crec1(noindex) 
     )) )<>0
  { 
    tmp_spr.tp   :=ww_tp
    tmp_spr.tbl  :=ww_tbl
    tmp_spr.crec :=ww_crec
    tmp_spr.crec1:=ww_crec1
    tmp_spr.name:=''
    case ww_tp of
    //значение аналитики 
    0:
    { if GetAnyKau(word(0),ww_tbl,ww_crec)
      { ww_str :=GivenAnName(1) // наименование
        ww_str1:=GivenAnName(2) //код
        case UserDeskRep.ResWord[39] of
        3,4: //Смета расходов на оплату труда
        { ww_str:=substr(ww_str,1,20) ; //просто подрежем
        }
        else
        { if substr(ww_str,1,length(ww_str1))=ww_str1  and (ww_tbl<10000 or (an_stru_spkau<>0 and an_stru_spkau<>3))
           ww_str:=substr(ww_str,length(ww_str1)+1,200)
        
          if false //ww_tbl=20001 // БДР
          { wc_spkau:=ww_crec
            if getfirst fastfirstrow spkau=0
              ww_str1:=spkau.levelcode
          }
          if ww_str='' ww_str:=ww_str1
        }
        End;  
        tmp_spr.name:=substr(ww_str,1,60)
         +if(ww_tbl>100 and ww_tbl<5000 or ww_tbl>10000,'/'+ww_str1,'');
      }
    }
    //наименование аналитики
    1:tmp_spr.name:=Analitik_Name(ww_tbl);
    2: //по справочникам
    { if ww_crec>0
      { case ww_tbl of
        coklvidopl: tmp_spr.name:=if(getfirst fastfirstrow klvidopl1 where (( ww_crec== klvidopl1.vidopl ))=0
          ,string(klvidopl1.vidoplp,4)+' '+klvidopl1.NVIDOPL,string(ww_crec,4));
        coklvidud: tmp_spr.name:=if(getfirst fastfirstrow klvidud1 where (( ww_crec== klvidud1.vidud ))=0
          ,string(klvidud1.vidudp,4)+' '+klvidud1.NVIDUD,string(ww_crec,4));
        coPerech: tmp_spr.name:=if(getfirst fastfirstrow Perech1 where (( ww_crec== Perech1.vidper ))=0
          ,string(Perech1.vidper,4)+' '+Perech1.nameper,string(ww_crec,4));
        coKlrejim: tmp_spr.name:=if(getfirst fastfirstrow Klrejim where (( ww_crec== Klrejim.rejim ))=0
          ,string(Klrejim.rejim,4)+' '+Klrejim.NREJIM,string(ww_crec,4));
        coCatalogs: tmp_spr.name:=if(getfirst fastfirstrow Catalogs where (( ww_crec== catalogs.nrec ))=0
          ,catalogs.name,'!? '+string(ww_crec,22));
        coKlSovm:  tmp_spr.name:=if(getfirst fastfirstrow KlSovm where (( ww_crec== klsovm.sovm ))=0
          ,KLSOVM.NSOVM,'!? '+string(ww_crec,22));
        coHozoper: tmp_spr.name:=if(getfirst fastfirstrow Hozoper where (( ww_crec== hozoper.nrec ))=0
          ,hozoper.name1,'');
        end;
      }
      else
      { tmp_spr.name:='';
      }    
    }
    3: // права доступа
    { tmp_spr.name:=if(DA.IsAvailable(ww_crec),'TRUE','FALSE')
    }
    4: // По штатному
    { tmp_spr.name:=string(GetAttrStaffByCexDol(UserDeskRep.ResComp[20],ww_crec,ww_crec1));
      if tmp_spr.name='0'
      { displ('!? Не нашли ВА к ШР, к должности, к СЕШР '+Katpodr.name+', '+Catalogs.name)
      }
    }
    5: // по сссылочному ВА
    { tmp_spr.name:=string(PiExtAttr.coGetAttrId(ww_tbl,ww_crec,ww_crec1))
    }
    
    6: //koд по NREC
    {  case ww_tbl of
       coKlrejim: tmp_spr.name:=if((getfirst fastfirstrow Klrejim where (( ww_crec== Klrejim.nrec ))=0)
          ,string(Klrejim.rejim),'');
       coKlKatego: tmp_spr.name:=if( (getfirst fastfirstrow KlKatego where (( ww_crec== KlKatego.nrec ))=0)
          ,string(KlKatego.kod),'');
       cospKau: tmp_spr.name:=if((getfirst fastfirstrow spkau where (( ww_crec== SpKau.nrec ))=0)
          ,spkau.code,'');  
       end;   
        
    }
    7: //для GetGalPodrByStaffDepart
    { tmp_spr.name:=if( (vStaff.getfirst extcatlinks where (( 11==extcatlinks.objtype and 1 ==extcatlinks.modtype
        and ww_crec == extcatlinks.staffcat )) =0), string(vStaff.extcatlinks.EXTCAT),'0');
    }
    8: // GetRegionNameByCexDopAn
    {    //РЕГИОН НАЗВАНИЕ
      wcc_podr:=OtpDOP_FindCex(ww_crec,ww_crec1);
      MyLogWrite(false,'=== GetNameSpr 8 '+string(wcc_podr)+' , '+string(ww_crec1) )
      ww_str1:='!? нет подразделение'
      if getfirst katpodr1=0
      { ww_str1:=KatPodr1.Name
        while tmp_spr.name='' or tmp_spr.name='//'
        { 
          ww_nrec:=KATPODR1.CUSER; //AdrFunc.GetATDNRec(KATPODR1.CUSER)
          if ww_nrec>0 
          { tmp_spr.name:=iAdrFunc.GetItem(ww_nrec,2,1) //наименование
            ww_nrec:=iAdrFunc.GetATDNRec(ww_nrec)
            ww_nrec:=iAdrFunc.GetNRecRegion(ww_nrec) //sterr.nrec;
            tmp_spr.name:=tmp_spr.name+'/'+iAdrFunc.GetOkato(ww_nrec)
              +'/'+iAdrFunc.GetItem(KATPODR1.CUSER,2,cgAtdGniCode)+'/'+iAdrFunc.GetItem(KATPODR1.CUSER,2,3) //Сокращенное название типа элемента АТД
            MyLogWrite(false,'    KatPodr1.Name='+KatPodr1.Name+', cuser='+string(KATPODR1.CUSER)+' '+tmp_spr.name )
         
            if tmp_spr.name<>'//' and tmp_spr.name<>'' then break;
          }  
          ww_nrec:=KatPodr1.cPodr
          if ww_nrec=0 then break;
          wcc_podr:=ww_nrec
          if getfirst KatPodr1<>0 then break;
         }
      }
      if tmp_spr.name='//' or tmp_spr.name=''
      { tmp_spr.name:='!?Не нашли регион для подр.'+ww_str1
      }

    }
    9:  //Function GetOKVEDNameByCexDopAn(ww_cex:nrec; ww_dop:nrec) :string;
    {
      wcc_podr:=OtpDOP_FindCex(ww_crec,ww_crec1);
      if getfirst katpodr1=0
      { while tmp_spr.name=''
        { 
/*
          RunInterface(PickCatalog2, 2040, _NRec, 0);

          if (GetFirst CATALOGS where ((_Nrec == CATALOGS.NRec)) = tsOk)
            set KATORG.OKONH := Trim(LTrim(CATALOGS.CODE + ', ' + CATALOGS.NAME, ','));
*/          
          if getfirst katorg_podr=0
            tmp_spr.name:=KatOrg_Podr.OKONH //
          if tmp_spr.name<>'' then
          { tmp_spr.name:=substr(tmp_spr.name,pos(',',tmp_spr.name)+1,200)
                +'/'+substr(tmp_spr.name,1,pos(',',tmp_spr.name))
            break;
          }  
          ww_nrec:=KatPodr1.cPodr
          if ww_nrec=0 then break;
          wcc_podr:=ww_nrec
          if getfirst KatPodr1<>0 then break;
         }
      }
      if tmp_spr.name='//' or tmp_spr.name=''
      { tmp_spr.name:='Не нашли ОКВЭД для подр.'+ww_str1
      }
    }
    end;
    insert current tmp_spr;
  };   
  GetNameSpr:=tmp_spr.name;
}


//==============================
Function GetKategKod(ww_nrec:comp):word;
//==============================
{ Result:=word(GetNameSpr(6,coKlkatego,ww_nrec) );
}

//==============================
//получить наименование по категории/виду работы
//==============================
Function GetKategSovmName(ww_kateg:word;ww_sovm:word) :string;
//==============================
{ Result:=''
//Руководители, специалисты, служащие всего	в т.ч.		Рабочие		
// 01 Руководители	
// 02 Специалисты, специалисты	
// 03 Рабочие			
// 04 Внешние совместители	
// 05 Работники,  выполнявшие работы по договорам ГПХ, другие лица несписочного состава

  case ww_sovm of
  1: // Внешние совместители Ц вид работы 1
  { Result:='04 Внешние совместители';
  }
  2,4://	Несписочный состав Ц вид работы 4
     //работники, выполнявшие работы по договорам ГПХ Ц виды оплат 8,10
  { Result:='05 Работники,  выполнявшие работы по договорам ГПХ, другие лица несписочного состава';
  }
  else
  {  case ww_kateg of
     1: Result:='01 Руководители';
     2,3: Result:='02 Специалисты, специалисты';
     else Result:='03 Рабочие';			
     end;
  }
  end;
  if logfilekl
    MyLogWrite(false,' GetKategSovmName , ww_kateg='+string(ww_kateg)+', ww_sovm='+string(ww_sovm) )
} //Function GetKategSovmName(ww_kateg:word;ww_sovm:word) :string;


//=======================================================
// получить наименование региона
//=======================================================
Function GetRegionNameByCexDopAn(ww_cex:comp; ww_dop:comp) :string;
{ Result:=GetNameSpr(8,coKatPodr,ww_cex, ww_dop)
}


//=======================================================
// получить наименование OKVED
//=======================================================
Function GetOKVEDNameByCexDopAn(ww_cex:comp; ww_dop:comp) :string;
{ Result:=GetNameSpr(9,coKatPodr,ww_cex, ww_dop)
}

//=======================================================
// получить наименование OKVED
//=======================================================
Function GetPODRNrecByCexDopAn(ww_cex:comp; ww_dop:comp) :comp;
{ Result:=OtpDOP_FindCex(ww_cex,ww_dop)
}

//==============================
Function GetRejimKod(ww_nrec:comp):word;
{ Result:=word(GetNameSpr(6,coKlRejim,ww_nrec) );
}

//==============================
// проверить фильтр
//==============================
Function Chk_Filter(const ww_cpodr :comp;const ww_ckateg:comp;const ww_cpost:comp; ww_rejim:word) :boolean;
{ Chk_Filter:=False;
  // только работники из подразделений, к которым разрешен доступ
  //if ww_rejim=0 then exit;
  //if not DA.IsAvailable(ww_cpodr) then exit
  if GetNameSpr(3,0,ww_cpodr)='FALSE' then exit;
  if userDeskRep.ResWord[1]=0
  { Chk_Filter:=true;exit;
  } 
  if (userDeskRep.ResWord[1] and 1)>0
  { if not FoundMarker(MarkerPodr,ww_cpodr) then exit;
  }
  if (userDeskRep.ResWord[1] and 2)>0
  { if getfirst klkatego where (( ww_ckateg  == klkatego.kod ))<>0 then exit;
    if not FoundMarker(MarkerKateg,klkatego.nrec) then exit;
  }
  if (userDeskRep.ResWord[1] and 4)>0
  { if not FoundMarker(MarkerPost,ww_cpost) then exit;
  }
  if (userDeskRep.ResWord[1] and 8)>0
  { if not FoundMarker(MarkerPost,ww_rejim) then exit;
  }
  MyLogWrite(false,' фильтр')
  Chk_Filter:=true
} //Function Chk_Filter(var ww_cpodr :comp;var ww_ckateg:comp) :boolean; 
//===================
// получить наименование подразделения
//==================
Function GetPodrName(ww_podr :comp) :string;
{ wcc_podr:=ww_podr;
  GetPodrName:=if(getfirst fastfirstrow katpodr1=0,katpodr1.name,'??? '+string(wcc_podr))
}
//============================
//получить nrec категории
//============================
Function GETKATEGNREC(ww_kateg:word) :comp;
{ w_kateg:=ww_kateg;
  GETKATEGNREC:=if(getfirst fastfirstrow klkatego1=0,klkatego1.nrec,0)
}
//============================
//получить наименование категории
//============================
Function GetKategName(ww_kateg:word) :string;
{ w_kateg:=ww_kateg;
  GetKategName:=if(getfirst fastfirstrow klkatego1=0,klkatego1.naikat,'??')
}
//===============================
// подсчитть неявки
//===============================
Function Calc_Neyavki:double;
var ii:word;
    wwsu:double;
{ wwsu:=0;
  //for(ii:=9;ii<=39;inc(ii)) 
  wwsu:=wwsu+TempDescr.sum[8]+TempDescr.sum[21]
  Calc_Neyavki:=wwsu;
}    
//===============================
// подсчитть явки
//===============================
Function Calc_yavki:double;
var ii:word;
    wwsu:double;
{ wwsu:=0;
  //for(ii:=3;ii<=8;inc(ii)) wwsu:=wwsu+TempDescr.sum[ii]
  wwsu:=TempDescr.Sum[6]
  Calc_yavki:=wwsu;

}
//===============================
// подсчитть неявки
//===============================
Function Calc_Neyavki1:double;
var ii:word;
    wwsu:double;
{ wwsu:=0;
  //for(ii:=9;ii<=39;inc(ii)) wwsu:=wwsu+tobot.sum[ii]
  wwsu:=wwsu+TempDescr.sum[8]+TempDescr.sum[21]
  Calc_Neyavki1:=wwsu;
}    
//===============================
// подсчитть явки
//===============================
Function Calc_yavki1:double;
var ii:word;
    wwsu:double;
{ wwsu:=0;
  //for(ii:=3;ii<=8;inc(ii)) wwsu:=wwsu+tobot.sum[ii]
  //wwsu:=wwsu+(Tobot.Sum[49] div 1000000)+(Tobot.Sum[50] div 1000000)
  wwsu:=wwsu+TempDescr.sum[5]
  
  Calc_yavki1:=wwsu;

}
//==========================================
// накрпить данные во временную таблицу
//==========================================
Procedure Tobot_Ins ;
{ if getfirst fastfirstrow tobot where (( 
      wc_cut1 == ToBot.cut[1] and wc_cut2 ==  ToBot.cut[2]
  and wc_cut3 == ToBot.cut[3] and wc_cut4 ==  ToBot.cut[4] 
  and wc_cut5 == ToBot.cut[5] and wc_cut6 ==  ToBot.cut[6]
 // and     CurCode == Tobot.code(noindex) 

  ))<>0
  { ClearBuffer(#Tobot);
    Tobot.nrec :=0;
    Tobot.IsLeaf    := 0;
    Tobot.code       :=CurCode;
    if false // isvalid(#tmp_persons)
    { Tobot.mSpDoc    := tmp_persons.Nrec; //Lstab.NRec;                                  // ссылка на базовый док-т
      Tobot.NameGroup := tmp_persons.fio ;  //wNameGr; // наименование на самом нижнем уровне
      Tobot.SortName  := tmp_persons.fio //wNameGr;
    }  
    Tobot.mSpDoc:=wc_lev
    Tobot.NameGroup := wNameGr;
    Tobot.SortName  := wNameGr //wNameGr;
    ToBot.cut[1]:=wc_cut1;Tobot.Group[1]:=wc_cut1;
    ToBot.cut[2]:=wc_cut2;Tobot.Group[2]:=wc_cut2;
    ToBot.cut[3]:=wc_cut3;Tobot.Group[3]:=wc_cut3;
    ToBot.cut[4]:=wc_cut4;Tobot.Group[4]:=wc_cut4; 
    ToBot.cut[5]:=wc_cut5;Tobot.Group[5]:=wc_cut5;
    ToBot.cut[6]:=wc_cut6;Tobot.Group[6]:=wc_cut6;
    insert current ToBot;
  }
  MyLogWrite(false,'Tobot_Ins '+Tobot.namegroup+'/'+lstab.tabn+'/'+lstab.strtabn);
} //Procedure Tobot_Ins ;
//===============================
//венруь номер колонки
//===============================
Function GetNumKolon(wkod:string;wwtype:word;ww_day:word):word;
{  wkod:=trim(wkod)
GetNumKolon:=0  
//	1
//	2
wkod:=upcase(wkod)
if wwtype=1
{

if wkod='Я' then GetNumKolon:=6
if wkod='СП' then GetNumKolon:=	6
if wkod='К' then GetNumKolon:=	6
if wkod='В' then GetNumKolon:=	16
if wkod='РП' then GetNumKolon:=	7
}
//	42
if wwtype=2
{
  if wkod='Я' then GetNumKolon:=	28
  if wkod='РР' then GetNumKolon:=	28
  if wkod='РП' then GetNumKolon:=	29
  if WT_TestDay(ww_day,dkHoliday,stPlanned) GetNumKolon:=	29
  if wkod='СВ1' then GetNumKolon:=	30
  if wkod='СВ2' then GetNumKolon:=	30 //СВ1
}
}//Function GetNumKolon(wkod:string;wwtype:word):word;
//===================================
// получить Nrec и наименование подразделения на заданом уровне
//===========================================
Function GetKatpodrIe(const ww_cex:comp;const wsvertka :word; var ww_name:string) :comp;
var ww_nrec :comp;
{ ww_nrec:=ww_cex;
  ww_name:='???'
  if wsvertka>0
  { iPodrFilterDef.katpodrGetLevel('',ww_nrec,wsvertka)
     ww_nrec:=iPodrFilterDef.katpodrGetLevelNrec(wsvertka)
  }
  ww_name:=GetPodrName(ww_nrec)
  GetKatpodrIe:=ww_nrec;
}
//========================================
// Получить уровень для аналитики
// 
//========================================
Function Analitik_GetLevel(const ww_sch:string[20];const ww_sub:string[20]): word;
{        /*
      Группировать явки/неявки нужно по КАУ: для счетов 
      20.01, 20.02, 23.01, 23.02, 25, 26 и 29.01 
      Ц КАУ 1-го уровня (пользовательская аналитика 
      лВиды продукции, работ, услуг╗). Эти счета привязаны по ШР. 

      Для 23.03 Ц только по КАУ 4-го уровня 
      (системная аналитика лОбъекты строительства╗, 40 код), 
      для 08 с различными субсчетами за исключением 70 субсчета 
      группируем только по КАУ 1-го уровня -  
      (системная аналитика лОбъекты строительства╗, 40 код). 
      Как-то так

       */
   if ww_sch='23' and ww_sub='03'
   { Analitik_GetLevel:=4
   }
   else
   if ww_sch='08'
   { Analitik_GetLevel:=1
   }
   else
   { Analitik_GetLevel:=1
   }
}
//=============================
// добавить аналитику
//=============================
Function Analitik_InsValue(wCurCode:word; ww_tbl :word ;ww_ckau:comp; 
         wie:word;const wsvertka :word; var ww_name:string;ww_option:word) :comp;
var  wnmkau,wnmkau1, wwcode:string;
     wwc_lev:comp;
     ww_nrec:comp;
     ww_level:word;
     j:word;  
     wwckau:comp;
{ wnmkau:=GetNameSpr(1,ww_tbl,0) //Analitik_Name(ww_tbl)
/*
  If (  GetAnyKAU(Word(0), KodTable[], KodKau[]), GivenAnName(1)), '')

Параметры GivenAnName() :
  cgAnName   = 1; // Наименование КАУ
  cgAnStrKod = 2; // системные String(NRec), ручные SpKau.Code
  cgAnStrKey = 3; // ключ для сортировки в отчетах, определяется по настройкам (StrName+StrKod) (StrKod+StrName)
  cgAnNode   = 4; // строковое представление cNode (вышестоящего элемента)
  cgAnAbbr   = 5; // уникальный строковый ID для использования в формулах (!!!не изменяется!!!)
  cgAnCode   = 6; // код, как правило для сортировки в каталогах; может меняться, может быть неуникальным
  cgAnSort   = 7; // строка для сортировки, но НЕ для группировки
*/
  wwckau :=ww_ckau 
  wnmkau1:=GetNameSpr(0,ww_tbl,ww_ckau) //if(GetAnyKau(word(0),ww_tbl,wwckau),GivenAnName(1),'')
  wwcode :=wnmkau+if(ww_tbl=40,'',' ') //+if(GetAnyKau(word(0),ww_tbl,wwckau),GivenAnName(6),'')
  if logfilekl
    MyLogwrite(false,'==== Analitik_InsValue = '+wwcode+'/'+wnmkau1)
  if getfirst fastfirstrow TmpKatalog where (( wCurCode  == TmpKatalog.Code
              and wwcode+'=='+wnmkau1 == TmpKatalog.Name )) <> tsOk
  { ClearBuffer(#TmpKatalog);
    TmpKatalog.Nrec:=0;
    TmpKatalog.Code:=wCurCode;
    TmpKatalog.Name := wwcode+'=='+wnmkau1;
    insert current TmpKatalog;
    wwc_lev:=TmpKatalog.nrec;
    ww_name:=TmpKatalog.name;
    ww_level:=1;
    ww_nrec:=TmpKatalog.Nrec;
    for(j:=1;j<=20;j++)
      dm_nrec[j]:=TmpKatalog.Nrec;
    if wie>0
    { if (ww_tbl>=100 and ww_tbl<5000) or ww_tbl>=10000 // польз.аналитика
      { // построить дерево
        if getfirst fastfirstrow spkau where (( wwckau == spkau.nrec ))=0
        do { //сдвинули поиск по древу
           if spkau.cnode=0 then break
           wwckau:=spkau.cnode;
           wnmkau1:=GetNameSpr(0,ww_tbl,wwckau) //if(GetAnyKau(word(0),ww_tbl,wwckau),GivenAnName(1),'')
           wwcode :=wnmkau+if(ww_tbl=40,'',' ') //+if(GetAnyKau(word(0),ww_tbl,wwckau),GivenAnName(6),'')
           if getfirst fastfirstrow TmpKatalog1 where (( TmpKatalog.nrec == TmpKatalog1.nrec ))=0 {}
           if getfirst fastfirstrow TmpKatalog where (( wCurCode  == TmpKatalog.Code
              and wwcode+'=='+wnmkau1 == TmpKatalog.Name )) <> tsOk
           { ClearBuffer(#TmpKatalog);
             TmpKatalog.Code:=wCurCode;
             TmpKatalog.Nrec:=0;
             TmpKatalog.Name :=  wwcode+'=='+wnmkau1;
             insert current TmpKatalog;
           }
              
           update current TmpKatalog1 set TmpKatalog1.cgroup:=TmpKatalog.nrec;
           ww_level:=ww_level+1;
           if ww_level<=20
             dm_nrec[ww_level]:=TmpKatalog.nrec;
           if logfilekl
             MyLogwrite(false,' уровень 1  '+string(ww_level)+'=' +TmpKatalog.Name+'/'+TmpKatalog.Name+'/'+string(TmpKatalog.NREC)+'/'+string(TmpKatalog1.NREC)) 
           if getfirst fastfirstrow spkau where (( wwckau == spkau.nrec ))<>0 then break;
        } while true;
      } //if wtbl>100
      else
      { if ww_tbl=40 and (ww_option and 1)>0 //Объекты строительства
        { if getfirst fastfirstrow katstroy where (( wwckau == katstroy.nrec ))=0
          do {
            if katstroy.CSTROY=0 then break
            wwckau:=katstroy.CSTROY;
            if wwckau=0 then break;
            wnmkau1:=GetNameSpr(0,ww_tbl,ww_ckau);//if(GetAnyKau(word(0),ww_tbl,wwckau),GivenAnName(1),'')
            wwcode :=wnmkau+if(ww_tbl=40,'',' ') //+if(GetAnyKau(word(0),ww_tbl,wwckau),GivenAnName(6),'')
               if getfirst fastfirstrow TmpKatalog1 where (( TmpKatalog.nrec == TmpKatalog1.nrec ))=0 {}
             if getfirst fastfirstrow TmpKatalog where (( wCurCode  == TmpKatalog.Code
              and wwcode+'=='+wnmkau1 == TmpKatalog.Name )) <> tsOk
            { ClearBuffer(#TmpKatalog);
              TmpKatalog.Nrec:=0;
              TmpKatalog.Code:=wCurCode;
              TmpKatalog.Name :=  wwcode+'=='+wnmkau1;
              insert current TmpKatalog;
            }
            ww_level:=ww_level+1;
            if ww_level<=20
              dm_nrec[ww_level]:=TmpKatalog.nrec;
            update current TmpKatalog1 set TmpKatalog1.cgroup:=TmpKatalog.nrec;
            if logfilekl
              MyLogwrite(false,' уровень 2  '+string(ww_level)+'=' +TmpKatalog.Name+'/'+TmpKatalog1.Name+'/'+string(TmpKatalog.NREC)+'/'+string(TmpKatalog1.NREC)) 
            if wwckau=0 then break;
            if getfirst fastfirstrow katstroy where (( wwckau == katstroy.nrec ))<>0 then break;
          } while true;
        } //if wtbl=40 and (UserDeskRep.ResWord[40] and 2)>0


        if ww_tbl=69 // категории
        { if pos('рабочие',locase(wnmkau1))=0
          { wnmkau1:='из них  руководители, специалисты, служащие'
            wwcode :=wnmkau+if(ww_tbl=40,'',' ') //+if(GetAnyKau(word(0),ww_tbl,wwckau),GivenAnName(6),'')
            if getfirst fastfirstrow TmpKatalog1 where (( TmpKatalog.nrec == TmpKatalog1.nrec ))=0 {}
            if getfirst fastfirstrow TmpKatalog where (( wCurCode  == TmpKatalog.Code
              and wwcode+'=='+wnmkau1 == TmpKatalog.Name )) <> tsOk
            { ClearBuffer(#TmpKatalog);
             TmpKatalog.Code:=wCurCode;
             TmpKatalog.Nrec:=0;
             TmpKatalog.Name :=  wwcode+'=='+wnmkau1;
             insert current TmpKatalog;
            }
            update current TmpKatalog1 set TmpKatalog1.cgroup:=TmpKatalog.nrec;
          }
        } //if ww_tbl=69 // категории

      } //else if wtbl>100



      if wsvertka>0
      { if ww_level>20 then ww_level:=20;
        for(j:=1;j<=ww_level;j++)
        { if getfirst fastfirstrow TmpKatalog where (( dm_nrec[j] == TmpKatalog.nrec ))=0
          { if j>(ww_level-wsvertka)
            { update current TmpKatalog set TmpKatalog.crec:=TmpKatalog.nrec 
            } 
            else
            { if (ww_level-wsvertka)<=19 //(ww_level-wsvertka)>0 and 
              {  update current TmpKatalog set TmpKatalog.crec:=dm_nrec[(ww_level-wsvertka)+1] 
              }
              else
              {  update current TmpKatalog set TmpKatalog.crec:= TmpKatalog.nrec;
              }
            }
          }
          if logfilekl
            mylogwrite(false,'Пробежка по дереву '+string(j)+'='+TmpKatalog.Name+'/'+string(TmpKatalog.NREC)+'/'+string(TmpKatalog.crec)) 
        }
        if getfirst fastfirstrow TmpKatalog where (( wwc_lev == TmpKatalog.nrec ))=0
        {  wwc_lev:=if(TmpKatalog.crec>0,TmpKatalog.crec,TmpKatalog.nrec);
           if getfirst fastfirstrow TmpKatalog where (( wwc_lev == TmpKatalog.nrec ))=0
             ww_name:=TmpKatalog.name;
          if logfilekl
            mylogwrite(false,'Выдаем аналитику '+ww_name+'/'+string(wwc_lev))              
        }   
      } //if mIeSvertka[i]>0
    } //if mHierar>0  
    if getfirst fastfirstrow TmpKatalog where (( wwc_lev == tmpKatalog.nrec )) =0 {}
  } //if getfirst fastfirstrow TmpKatalog wher
  else
  { wwc_lev:=TmpKatalog.nrec;
    ww_name:=TmpKatalog.name;
     if  wsvertka>0
     { wc_lev:=TmpKatalog.crec;
       if wwc_lev=0 then wc_lev:=TmpKatalog.nrec;
       if getfirst fastfirstrow TmpKatalog where (( wc_lev == TmpKatalog.nrec ))=0
            ww_name:=TmpKatalog.name;
      }   
      if logfilekl
        mylogwrite(false,'Выдаем аналитику '+ww_name+'/'+string(wwc_lev))              
  } //else if getfirst fastfirstrow TmpKatalog where
  if logfilekl
    mylogwrite(false,string(wc_lev)+','+ww_name)
  Analitik_InsValue:=wc_lev
}




//== добавть во временный справочник
Function InsTmpKatalog(wCurCode:word;wkod_gr:word;ww_name:string):comp;
{   if getfirst fastfirstrow TmpKatalog where (( wCurCode  == TmpKatalog.Code
              and string(wkod_gr)+'=='+ww_name == TmpKatalog.Name )) <> tsOk
  { ClearBuffer(#TmpKatalog);
    TmpKatalog.Nrec:=0;
    TmpKatalog.Code:=wCurCode;
    TmpKatalog.Name := wkod_gr+'=='+ww_name;
    insert current TmpKatalog;
  }
  InsTmpKatalog:=TmpKatalog.Nrec;
}
//==============================
// сбор данных по табелю
//==============================
Procedure InsTabel(Change:comp);
VAR
  WCKAU:COMP;
  wtbl :word;
  kl_vihod : boolean;
  i,j,k : word;
  ww_analitik_lev:word;
  wHours: double;
  wDays: byte;
  wKind: word;
  ww_str:string;
{ 
  if logfilekl
    mylogwrite(false,'InsTabel '+string(lstab.tabn)+'/'+string(Change));
  WT_ResetFilter;
  // если включено раздельное ведение табелей
  //    if (SeparateTableKeeping)
  // установим фильтр по данному переходу в межпериод
  WT_SetAttributeFilter(wtaChange, Change);
  // если используется группировка по аналитикам
  /*
    if (wAnalitikVal <> 0)
    WT_AddAnalyticsFilter(wAnalitikVal, SortingTable.Code);

      // отбросить редуцированные части табелей
      if WT_GetDaysBwDates(dkEnabled, stActual, CurrentPeriodBeginning, CurrentPeriodEnding) = 0
        exit;
  */
  
  WT_AddDayRangeFilter(day_b,day_e) 
  for(i:=1;i<=Grp_Count+1;i:=i+1) //if(UserDeskRep.ResWord[39] =7,0,1)
  { wc_lev:=0; // wNameGr:='';
    if i<=Grp_Count
    {case mTable[i] of
     coKatPodr:
     { case   mGroup[Len1] of   //UserDeskRep.ResWord[11+(i-1)*2] of
       12://'Подразделение+доп/аналитика' //12
       { wc_lev:=GetKatpodrIe(
               GetPodrNrecByCexDopAn(if(change=0, lstab.cexoz,perexod.cexp)
             , if(change=0,lstab.OLDCLSCH,Perexod.OLDCLSCH)),mIeSvertka[i],wNameGr)
             }
       else 
       { wc_lev:=GetKatpodrIe(if(change=0, lstab.cexoz,perexod.cexp),mIeSvertka[i],wNameGr)
       }
       end;
       
       
     }
     coKlKatego:
     { wc_lev:=if(change=0, GetKategNrec(lstab.kateg),GetKategNrec(perexod.kateg) )
       if  i=Grp_Count
         wNameGr:=GetKategName(if(change=0, lstab.kateg,perexod.kateg ))
       
     }
     coPersons:
     { wc_lev:=lstab.tperson
       if  i=Grp_Count
         wNameGr:=tmp_persons.fio;
     }
     coTmpKatalog:
     { if Change=0
       { wsch :=lstab.cschetd; wsubsch:=lstab.csubschd;
       }
       else
       { wsch :=perexod.cschetd; wsubsch:=perexod.csubschd;
       }
       case mGroup[i] of //UserDeskRep.ResWord[11+(i-1)*2] of
       5: //ВА к штатному/должности
       { wTBL := ATTRNAM_SH.ROBJECT
         /*
         wckau:=GetAttrStaffByCexDol(UserDeskRep.ResComp[20]
           ,if(change=0,lstab.Cexoz,perexod.cexp)
           ,if(change=0,lstab.cAppoint,perexod.cAppoint)
           )
         */  
         wckau:=comp(GetNameSpr(4 , wTBL
            ,if(change=0,lstab.Cexoz,perexod.cexp)
            ,if(change=0,lstab.cAppoint,perexod.cAppoint)
           ) );
         wc_lev:=Analitik_InsValue(CurCode,wtbl,wckau,mHierar[i], mIeSvertka[i],wNameGr,if((UserDeskRep.ResWord[40] and 2)>0,1,0))
         if logfilekl  mylogwrite(false,'== '+string(wtbl)+','+string(wckau)+','+string(wc_lev)+','+string(change) )
    
       }  
       6: //Категория с иерархией
       { wTBL := 69
         wckau:=if(change=0, GetKategNrec(lstab.kateg),GetKategNrec(perexod.kateg))
         wc_lev:=Analitik_InsValue(CurCode,wtbl,wckau,mHierar[i], mIeSvertka[i],wNameGr,if((UserDeskRep.ResWord[40] and 2)>0,1,0))
       } 
       7:{//'По месяцу начисления' //27
         //wc_lev:=InsTmpKatalog(CurCode,UserDeskRep.ResWord[11+(i-1)*2], string(Lstab.mesn,2));
         wc_lev:=InsTmpKatalog(CurCode,i, string(Lstab.mesn,2));
        
       }
       8:{//,'По счету/субсчету'                   //8
         wsch   :=if(change=0,lstab.cschetd ,perexod.cschetd )
         wsubsch:=if(change=0,lstab.csubschd,perexod.csubschd)
         //wc_lev:=InsTmpKatalog(CurCode,UserDeskRep.ResWord[11+(i-1)*2],wsch+'/'+wsubsch)
         wc_lev:=InsTmpKatalog(CurCode,i,wsch+'/'+wsubsch)

       }
       9: //
       { wsch   :=GetKategSovmName(if(change=0,lstab.kateg,perexod.kateg), lschet.sovm)
         //wc_lev:=InsTmpKatalog(CurCode,UserDeskRep.ResWord[11+(i-1)*2],wsch)
         wc_lev:=InsTmpKatalog(CurCode,i,wsch)
       }
       10://'Регион(c уч.доп.аналитики)' //10
       { ww_str   :=GetRegionNameByCexDopAn(if(change=0,lstab.cexoz,perexod.cexp), if(change=0,lstab.OLDCLSCH,Perexod.OLDCLSCH))
         //wc_lev:=InsTmpKatalog(CurCode,UserDeskRep.ResWord[11+(i-1)*2],wsch)
         wc_lev:=InsTmpKatalog(CurCode,i,ww_str)
       }
       11://'ОКВЭД (c уч.доп.аналитики)'  //11
       { ww_str   :=GetOKVEDNameByCexDopAn(if(change=0,lstab.cexoz,perexod.cexp), if(change=0,lstab.OLDCLSCH,Perexod.OLDCLSCH))
         //wc_lev:=InsTmpKatalog(CurCode,UserDeskRep.ResWord[11+(i-1)*2],wsch)
         wc_lev:=InsTmpKatalog(CurCode,i,ww_str)
       }
       13: //должность
       { ww_str:=GetNameSpr(2,coCatalogs,if(change=0,lstab.cappoint,perexod.cappoint))
         wc_lev:=InsTmpKatalog(CurCode,i,ww_str)
       }
       14: // объект строительства
       { ww_str:='=='
          wckau:=0
        
         for(k:=1;k<=6;k++)
         { if if(change=0, lstab.TBLD[k],perexod.TBLD[k])=40
           { wckau:=if(change=0, lstab.CKAUD[k],perexod.CKAUD[k])
             if getfirst fastfirstrow katstroy where (( wckau == katstroy.nrec )) =0
             ww_str:=' '+katstroy.name+'='+DateToStr(katstroy.DENDPROEKT,'DD/MM/YYYY')
           }
         }
         if wckau=0 //         ww_str='=='
         { wckau:=if(change=0, lstab.cexoz,perexod.cexp)
           if getfirst katpodr where (( wckau == katpodr.nrec ))=0
             ww_str:=katpodr.name
         }
         wc_lev:=InsTmpKatalog(CurCode,i,ww_str);
         
       }
       else
       { ww_analitik_lev:=Analitik_GetLevel(wsch,wsubsch)
         wckau:=if(change=0, lstab.CKAUD[ww_analitik_lev],perexod.CKAUD[ww_analitik_lev])
         wTBL:=if(change=0, lstab.TBLD[ww_analitik_lev],perexod.TBLD[ww_analitik_lev])
         wc_lev:=Analitik_InsValue(CurCode,wtbl,wckau,mHierar[i], mIeSvertka[i],wNameGr,if((UserDeskRep.ResWord[40] and 2)>0,1,0))
       }
       end;  
       if  i=Grp_Count
         wNameGr:=TmpKatalog.name;
       
     } //coTmpKatalog:
     end;
    }else
    {  wc_lev:=lstab.tperson
       if getfirst fastfirstrow tmp_persons=0
       { wNameGr:=tmp_persons.fio;
       }
       else
       { wNameGr:='-'
       }
    } 

     case i of
     1: wc_cut1:=wc_lev;
     2: wc_cut2:=wc_lev;
     3: wc_cut3:=wc_lev;
     4: wc_cut4:=wc_lev;
     5: wc_cut5:=wc_lev;
     6: wc_cut6:=wc_lev;
     end;
     /*
     if UserDeskRep.ResWord[39] =7
     { if i>Grp_count then
       { wc_lev:=0;
         wNameGr:=''
         continue;
       }
     } */

  } //for(i:=1;i<=6;i:=i+1) 
  Tobot_Ins;
  //Явочные часы
  var dm_days ,dm_hours :double;
  dm_days:=0; dm_hours:=0;
  //i:=GetNumKolon('В',1);
  //Tobot.Sum[i]:=Tobot.Sum[i]+ WT_GetDaysBwDays(hkHoliday, stActual, day_b, day_e); 
  // неявки
  kl_vihod:=false;
  if WT_LoadMonthlyAbsences = 0
  { for(j := 0; j < WT_GetAbsenceCount(atMonthly); Inc(j))
    { var wNotation: comp;
      if not WT_GetAbsenceAttribute(atMonthly, j, aaNotation, wNotation)
      or (wNotation = 0) then  continue;
        wHours:=0;wDays:=0;wKind:=0;
        WT_GetAbsenceAttribute(atMonthly, j,aaKind , wKind);
        var Beginning: date; // начало неявки в периоде
        if not WT_GetMonthlyAbsenceAttribute(j, aaBeginning, Beginning)  continue;
        var Ending: date; // конец неявки в периоде
        if not WT_GetMonthlyAbsenceAttribute(j, aaEnding, Ending)
        continue;

        if wc_Notation_V=wNotation 
        { //WT_GetDaysBwDays
           if (not kl_vihod)
           {
             wDays := //WT_GetDays(dkWeekend, 1)//WT_GetDays(dkHoliday,1)+
             WT_GetDaysBwDates(dkWeeKend,1, Beginning,Ending)
             //wDaysP:=WT_GetDays(dkWeekend, 0)//WT_GetDays(dkHoliday,0)+
             //wDaysB:=WT_GetDays(dkWeekend,-1)//WT_GetDays(dkHoliday,0)+
             if Change=0
             { wDays:=kol_vixod
             }
             else
             { kol_vixod:=kol_vixod-wDays;
               if kol_vixod<0 then
               { wdays:=wDays+byte(kol_vixod) ;kol_vixod:=0;
               }
             }
             mylogwrite(false,'InsTable '+string(change)+', выходные='+string(wDays));  
             kl_vihod:=true;
             
           }   else
           {   WT_GetAbsenceAttribute(atMonthly, j, aaDays, wDays);
           }
          
        }
        else
        { WT_GetAbsenceAttribute(atMonthly, j, aaHours, wHours);
          WT_GetAbsenceAttribute(atMonthly, j, aaDays, wDays);
        } 
        
        //logstrtofile('!lstab.log',string(wNotation)+'/'+string(k)+'/'+string(wDays)+'/'+string(wHours) )
        if wKind=akBusinessTrip
        { if wc_Notation_SP=wNotation  //Только СП!
          { 
             wHours:=wHours-(WT_GHBD(hkOverwork, 0, 0, stActual, Beginning, Ending)+WT_GHBD(hkOverworkRest, 0, 0, stActual, Beginning, Ending));
             dm_days:=dm_days-wDays;dm_Hours:=dm_Hours-wHours 
             //logstrtofile('!lstab.log','СП= '+string(wHours) )
          }
          //logstrtofile('!lstab.log','коман.')
        }
        if v1.getfirst fastfirstrow tmp_UO where (( wNotation == tmp_UO.nrec ))=0
        { i:=word(v1.tmp_UO.column_dn);
          if v1.tmp_UO.NUM='СП' or v1.tmp_UO.NUM='ВМ'
          {
          }
          if i=0
            i:= GetNumKolon(v1.tmp_UO.NUM,1,1)
          if i>0 then Tobot.Sum[i]:=Tobot.Sum[i]+wDays; 
          case  i of
          6 :  i:=28; // отработано дней
          7 :  i:=29;
          else i:=0 ;
          end;
          if i>0 then 
          { Tobot.Sum[i]:=Tobot.Sum[i]+wHours; 
          } 
          
        } //if v1.getfirst fastfirstrow UOWRKTABEL where (( wNotation == UOWRKTABEL.nrec ))=0
        
    }//for(j := 0; j < WT_GetAbsenceCount(atMonthly); Inc(j))
  }//if WT_LoadMonthlyAbsences = 0
  wHours:=WT_GetHours(hkOverwork,stActual)
  if wHours>0
  { i:=GetNumKolon('СВ1',2,1);
    if i>0 then 
    { Tobot.Sum[i]:=Tobot.Sum[i]+wHours; 
    }                  
  }
  wHours:=WT_GetHours(hkOverworkRest,stActual)
  if wHours>0
  { i:=GetNumKolon('СВ2',2,1);
    if i>0 then 
    { Tobot.Sum[i]:=Tobot.Sum[i]+wHours; 
    }                  
  }
  //==ночные
  wHours:=WT_GetHours(3,1)
  if wHours>0
  { i:=GetNumKolon('Н',2,1);
    if i>0 then 
    { Tobot.Sum[i]:=Tobot.Sum[i]+wHours; 
    }                  
  }
  wHours:=WT_GetHours(hkHoliday, stActual)+WT_GetHours(hkWeekend, stActual); 
  if wHours>0
  { i:=GetNumKolon('РП',2,1);
    if i>0 then 
    { Tobot.Sum[i]:=Tobot.Sum[i]+wHours; 
    }                  
    wHours:=WT_GetDays(dkWorkingHoliday, stActual)+WT_GetDays(dkWorkingWeekend, stActual); ; 
    i:=GetNumKolon('РП',1,1);
    if i>0 then 
    { Tobot.Sum[i]:=Tobot.Sum[i]+wHours; 
    }                  
    
  }
  //=========

  if Change=0 and (not kl_vihod) and kol_vixod>0
  { i:=GetNumKolon('В',1,1);
    if i>0 then Tobot.Sum[i]:=Tobot.Sum[i]+kol_vixod; 
    if logfilekl
      mylogwrite(false,' вых.= '+string(i)+', '+string(lstab.tabn)+', выходных='+string(kol_vixod))
          
  }
  i:=GetNumKolon('Я',2,0);
  dm_hours :=dm_hours+WT_GetHoursBwDays(hkWorking, 0, 0, stActual, day_b, day_e); 
  if dm_hours< 0 dm_hours:=0; 
  Tobot.Sum[i]:=Tobot.Sum[i]+dm_hours;
  i:=GetNumKolon('Я',1,0);
  dm_days:=dm_days+WT_GetDaysBwDays(dkWorking, stActual, day_b, day_e); 
  if logfilekl
    mylogwrite(false,'Явки '+string(dm_days)+'/'+string(WT_GetDaysBwDays(dkWorking, stActual, day_b, day_e)))
  if dm_days<0 then dm_days:=0
  Tobot.Sum[i]:=Tobot.Sum[i]+dm_days; 
  if logfilekl
    mylogwrite(false,'Явки '+string(dm_days)+'/'+string(WT_GetDaysBwDays(dkWorking, stActual, day_b, day_e))+'/'+string(Tobot.sum[3]))
  // календарные дний
  Tobot.Sum[1]:=Tobot.Sum[1]+WT_GetDaysBwDays(dkCalendarWorking,stPlanned, day_b, day_e);
  //+1+day_e-day_b WT_GetDaysBwDays(dkWorking, stPlanned, day_b, day_e);
  Tobot.Sum[5]:=Tobot.Sum[5]+WT_GetHoursBwDays(hkWorking, 0, 0, stPlanned, day_b, day_e);
 
  update current ToBot;
}//Procedure InsTabel(Change:comp);
//==========================
Procedure Tabel_Init;
{ Loadworkingtable(lstab.clschet,w_MesRas,w_YearRas)
  WT_ResetFilter;
  kol_vixod:=WT_GetDaysBwDates(dkWeeKend,1, dtb,dte)
  if logfilekl
    mylogwrite(false,'Табель '+string(lstab.tabn)+', выходных='+string(kol_vixod))
           
}    
//==============================
// сбор данных
//==============================
Function SborData : boolean;
var wwkl_first :boolean;
{ SborData:=False;
  if logfilekl
    MyLogwrite(false,'==== SborData01 ========= ')
  _loop fullcache lstab                                         
  { if not nextvisual then exit;
    if logfilekl
      MyLogwrite(false,'   lstab.tabn='+string(lstab.tabn) )
    w_lschet:=lstab.clschet;
    if getfirst fastfirstrow lschet=0 {}
    w_person:=lschet.tperson;
    if getfirst fastfirstrow tmp_persons=0 {}
    if lschet.datuv <>date(0,0,0) and lschet.datuv<dtb then continue;
    wwkl_first:=true;

    _loop fullcache perexod  
    { if chk_filter(perexod.cexp,perexod.kateg,perexod.cappoint,perexod.rejim) 
      {  if wwkl_first
         { Tabel_Init;
           wwkl_first:=false;
         }
         InsTabel(perexod.nrec)
         
      }   //if chk_filter(perexod.cexp,perexod.kateg) 
    } //_loop fullcache perexod  
    if chk_filter(lstab.cexoz,lstab.kateg,lstab.cappoint,lstab.rejim) 
    {  // табель фльтр уже прошел - только тогда вставляем
      if wwkl_first
      { Tabel_Init;
        wwkl_first:=false;
      }
      InsTabel(0)
    }    
  } // _loop lstab
  SborData:=true;
  
} //Function SborData : boolean;
//=============================
// печать имени группировки
//============================
Function PrintName(const ww_name:string):string;
var kk:word
{ kk:=pos(':',ww_name)
  if kk>0  ww_name:=substr(ww_name,kk+1,200)
  if pos('==',ww_name)>0
  { Result:=trim(substr(ww_name,pos('==',ww_name)+2,100))
  }
  else
  { Result:=trim(ww_name);
  }
} //Function PrintName(const ww_name:string):string;



//==============================
// печать данныъ
//==============================
Function PrintDoc_00(ww_type:word) : boolean;
VAR
 boIsTerm :boolean;
 wnpp:longint;
 wwkl:boolean;
 wLevel_Start: word;
 wCurLevel,wPrevLevel:longint;
 wsu_neayv :double;
 dm_num:array [0..100] of longint;
 str_num :string;
 i:word;
{ wexrow:=2;wexcol:=1;
  if ExcelInit(nmtemplate,true,2009)<>0
  { message('Ошибка инициализации шаблона')
    exit ;
  }
  StartNewVisual(vtNumericVisual,vfTimer+vfBreak,'Идет печать...', vfTimer+vfBreak);

  PrintDoc_00:=false;
  MyPutExcel('Баланс отработанного времени c '
    +DateToStr(UserDeskRep.ResDate[1],'DD/MM/YYYY по ') 
    +DateToStr(UserDeskRep.ResDate[2],'DD/MM/YYYY') 
    ,10,0,-1,-1)
  HeaderStrCount:=11;  
  wexrow:=HeaderStrCount+1;
  MyXlCreaMatrix(10000,70)
  wexrow:=wexrow-1;
  case ww_type of
  0,2: wwkl:=TreeGetFirstEx(MainTree );
  1: { wwkl:=true; wLevel_Start:=TreeLevel(MainTree);}
  else exit;
  end;
  wCurLevel:=0;
  for(wnpp:=0;wnpp<100;wnpp++) dm_num[wnpp]:=0;
  wnpp:=0;
  if  wwkl
  do
  {   if not nextvisual then break;
      Mylogwrite(false,'TempDescr.name='+TempDescr.name+'/'+string(wnpp))
      wPrevLevel := wCurLevel;
      wCurLevel  := TreeLevel(MainTree);
      if wCurLevel<wPrevLevel
      { for(wnpp:=wCurLevel+1;wnpp<=wPrevLevel;wnpp++) dm_num[wnpp]:=0;
      
      }
      str_num:=''
      if TempDescr.name<>'в том числе'
      { dm_num[wCurLevel]:=dm_num[wCurLevel]+1;
        for(wnpp:=0;wnpp<=wCurLevel;wnpp++)
        { if wnpp<3
            str_num:=str_num+if(wnpp=0,chr(39),'.')+string(dm_num[wnpp])
        }
      }
      boIsTerm   := TreeIsTerminal( MainTree );
      if (not boIsTerm) or ((UserDeskRep.ResWord[40] and 8)>0) or TempDescr.name='в том числе'
      { wexrow:=wexrow+1; wexcol:=1;
        wnpp:=wnpp+1;
        MyPutExcel(str_num,10,0,-1,-1)
        //string(wCurLevel)
        MyPutExcel(lpad(' ',wcurlevel*2)+PrintName(TempDescr.name),10,0,-1,-1)
        //wsu_neayv:=Calc_Neyavki;
        if TempDescr.name<>'в том числе' // 
        for(i:=3;i<=30;i++)
        { case i of
          1 :MyPutExcelNumber(round(TempDescr.sum[i],2),1,10,0,-1,-1);
          else
          { MyPutExcelNumber(round(TempDescr.sum[i],2),1,10,0,-1,-1)
          };
          end;
        }// for(i:=3;i<=64) 
      } //  
      case ww_type of
      0:
      { wwkl:=TreeGetNextEx(MainTree)
      }
      1:
      { wwkl:=TreeGetNextEx(MainTree)
        if wwkl
        if  ww_type=1 and TreeLevel(MainTree)<=wLevel_Start wwkl:=false;
      }
      2:
      { wwkl:=TreeGetNext(MainTree)
      }
      else
      { wwkl:=false;
      }
      end;
  }    
  While ( wwkl );
  MyxlWriteMatrix(wexrow);
  xlFreeMatrix;
  
  matrixkl:=False;
  MyxlFrameCells(63, 2, 1, 1,
     HeaderStrCount,1,wexrow,30);
  //xlSetFontStyle(xlBold, wexrow,1,wexrow,17);
  MyXlEnd;
  StopVisual('',0);
  PrintDoc_00:=true ;
} //Function PrintDoc_00 : boolean;
//===============================
// Чистка таблиц
//===============================
Procedure ClearTable (wwCurCode :word;TMp_Kat:boolean=True);
{ ReReadRecord(#tobot)
  ReReadRecord(#TempDescr)
  ResetBounds(#tobot)
  delete all tobot;
  delete tobot where (( wwcurcode == tobot.code )) ;
  if getfirst tobot where (( wwcurcode == tobot.code ))=0
  delete tobot where (( wwcurcode == tobot.code )) ;
  if getfirst tobot=0 {}
  delete tobot where (( wwcurcode == tobot.code ));
  if getfirst tobot=0 {}
  delete tobot where (( wwcurcode == tobot.code ));
  if getfirst tobot=0 {}
  setBounds(#tobot)

  ResetBounds(#TempDescr)
  if getfirst TempDescr=0 {}
  delete TempDescr where (( wwcurcode == TempDescr.code ));
  if getfirst TempDescr=0 {}
  delete TempDescr where (( wwcurcode == TempDescr.code ));
  if getfirst TempDescr=0 {}
  setBounds(#TempDescr)
  if TMp_Kat
  { delete all TmpKatalog ;
    delete TmpKatalog where (( wwcurcode == TmpKatalog.code ));
    delete TmpKatalog where (( wwcurcode == TmpKatalog.code ));
  }

}
//==============================
// добавить настройки группировок
//==============================
Procedure Add_Group(ww_num:word;ww_gr :word;ww_ie:word;ww_iesv:word);
{ if ww_gr=0 then exit;
  len1:=len1+1;
//mLevel[Len1]    := RepGroup.Nomer;
  mLevel[Len1]    := len1;
  mHierar[Len1]   := if(ww_ie>0,1,0);
  mKol[Len1]      := ww_ie;
  mGrupSort[Len1] := 0;
  mIeSvertka[Len1]:=ww_iesv;
  mGroup[Len1]:=ww_gr   
  case ww_gr of
  99:
  {  mTable[Len1] := 0;
     mName[Len1]  :='Всего по отчету'

  }
  1: {  
      mTable[Len1]    := coKatPodr;
      mName[Len1]:='Подр.:'
  }
  2:
  {
     mTable[Len1]    := coKlKatego;
      mName[Len1]:='Категория:'
  }
  3:{
    mTable[Len1]    := coTmpKatalog;
    mName[Len1]:='Аналитика:'
  }
  4:{
    mTable[Len1]    := coPersons;
    mGrupSort[Len1] := 0;
    mName[Len1]:=''
  }
  5: // ВА к штатному
  { mTable[Len1] := coTmpKatalog;
    mName[Len1]  :=''
  }
  6: // Категория в иерархии
  { mTable[Len1] := coTmpKatalog;
    mName[Len1]  :=''
  }
  7: // Категория в иерархии
  { mTable[Len1] := coTmpKatalog;
    mName[Len1]  :=''
  }
  8: // Счет/субсчет
  { mTable[Len1] := coTmpKatalog;
    mName[Len1]  :=''
  }
  9: // Вид работы категория
  { mTable[Len1] := coTmpKatalog;
    mName[Len1]  :=''
  }
  10://'Регион(c уч.доп.аналитики)' //10
  { //need_dop_an:=True
    need_cex:=true;
    mTable[Len1] := coTmpKatalog;
    mName[Len1]  :=''
  }
  11://'ОКВЭД (c уч.доп.аналитики)'  //11
  { //need_dop_an:=True
    need_cex:=true;
    mTable[Len1] := coTmpKatalog;
    mName[Len1]  :=''
  }
  12://'Подразделение+доп/аналитика' //12
  { need_dop_an:=True
    need_cex:=true;
    mTable[Len1] := coKatPodr;
    mVnKau[Len1]:=2;
    mName[Len1]  :=''
  }
  13://должность
  { //need_dop_an:=True
    need_cex:=true;
    mTable[Len1] := coTmpKatalog;
    mName[Len1]  :=''
  }
  14://объект строительства
  { //need_dop_an:=True
    need_cex:=true;
    mTable[Len1] := coTmpKatalog;
    mName[Len1]  :=''
  }
  end;   

}
//==============================
// запуск отчета
//==============================
Function CreateReport :boolean;
var ww_dt :date;
    ww_su:double;
    i,j :word;
    ww_nrec, ww_nrec1: comp;
    ww_lev_mes :word;
{ CreateReport:=false;
  logfilekl:=if((UserDeskRep.ResWord[40] and 4 )>0,true,false)
  ww_dt:=UserDeskRep.ResDate[1]
  ClearTable(CurCode,false)
  ClearTable(CurCode+1,false)
  ClearTable(CurCode+2,false)
  ClearTable(CurCode+3,false)

  if UserDeskRep.ResDate[1]>UserDeskRep.ResDate[2]
  { message('Дата конца периода меньше начала')
    exit;
  }
  PushBounds(#lsTab);
  if logfilekl
    MyLogwrite(false,'==== Сбор среднесписочной ========= ')

  v1.delete all tmp_uo;
  case UserDeskRep.ResWord[39] of
  7:
  { v1.insert into tmp_uo select UOWRKTABEL.NREC,UOWRKTABEL.NUM
     //ATTRVAL.VDouble
       ,if(UOWRKTABEL.NUM='ВМ',12 // Межвахта Ц обозначение в табеле ВМ (системное отклонение К)
       ,if(UOWRKTABEL.NUM='ОТ' or UOWRKTABEL.NUM='ОД'  ,13 //Столбец отпуск Ц системные отклонения ОТ, ОД, 
       ,if(UOWRKTABEL.NUM='Б' ,14 //Столбец б/л Ц системные отклонения Б
       ,if(UOWRKTABEL.NUM='НН' ,15 //Столбец н/н Ц системные отклонения НН
       ,if(UOWRKTABEL.NUM='ДП' ,16 //Столбец Дни в пути Ц обозначение ДП
    //Столбец Транзит не заполняется
      , if((UOWRKTABEL.PRIZ and 2)>0 and  CURLS.FIO<>'K'  ,11 ////  Столбец Объект Ц все явки из табеля      
      ,20 ))))))
      , 0
     //10
     from UOWrkTabel, CurLS
     where ((    UOWrkTabel.NRec   == CurLS.CPODR
           ));

  }
  else
  {
    v1.insert into tmp_uo select UOWRKTABEL.NREC,UOWRKTABEL.NUM,ATTRVAL.VDouble,0
    from UOWRKTABEL,ATTRNAM,ATTRVAL
    where ((
        coUOWRKTABEL == ATTRNAM.wTable
     and  'Баланс раб.времени, Дни' == ATTRNAM.Name     
     and  coUOWRKTABEL    == ATTRVAL.wTable
     and  ATTRNAM.Nrec    == ATTRVAL.cAttrNam
     and  UOWRKTABEL.NREC == ATTRVAL.cRec
  
    ));
  }  
  end;
  pushbounds(#lstab);
  InitWorkingTable;

  //CurCode:=0;
  ClearTable(CurCode,false)
  ClearTable(CurCode+1,false)
  //logfilenm:='!wt_balans.log'
  // для свертки подразделений
  iPodrFilterDef.katpodrGetLevelInit;
  iPodrFilterDef.SetLogFile(if(logfilekl,logfilenm,'')) 
  //MyLogwrite(true,'START')
  CurGroup:=0;
  len1:=0
  wc_Notation_SP:=0;wc_Notation_V:=0;
  if v1.getfirst fastfirstrow UOWRKTABEL where (('В' == UOWRKTABEL.NUM ))=0
    wc_Notation_V:=v1.UOWRKTABEL.Nrec
  if v1.getfirst fastfirstrow UOWRKTABEL where (('СП' == UOWRKTABEL.NUM ))=0
    wc_Notation_SP:=v1.UOWRKTABEL.Nrec
   //Add_Group(1,99,0)
   Add_Group(1,UserDeskRep.ResWord[11],UserDeskRep.ResWord[12],UserDeskRep.ResWord[31])
   Add_Group(2,UserDeskRep.ResWord[13],UserDeskRep.ResWord[14],UserDeskRep.ResWord[32])
   Add_Group(3,UserDeskRep.ResWord[15],UserDeskRep.ResWord[16],UserDeskRep.ResWord[33])
   Add_Group(4,UserDeskRep.ResWord[17],UserDeskRep.ResWord[18],UserDeskRep.ResWord[34])
   Add_Group(5,UserDeskRep.ResWord[19],UserDeskRep.ResWord[20],UserDeskRep.ResWord[35])
   ww_lev_mes:=0;
   for(i:=1;i<=5;i++) 
   { if UserDeskRep.ResWord[11+(i-1)*2]=7
     {  ww_lev_mes:=i
        break;
     }
   }  
   Grp_Count:=Len1
   mylogwrite(false,'Число уровней '+string(Grp_Count));
   do 
   { 
     w_YearRas:=year(ww_dt)
     w_MesRas :=month(ww_dt)
     if w_MesRas=month(UserDeskRep.ResDate[2]) and year(UserDeskRep.ResDate[2])=w_YearRas
     { dte:=UserDeskRep.ResDate[2]
     }
     else
     { dte:=date(last_day(ww_dt),w_MesRas,w_YearRas)
     }
     vStaff.DTB:= ww_dt
     vStaff.DTE:= dte

     if w_MesRas=month(UserDeskRep.ResDate[1]) and year(UserDeskRep.ResDate[1])=w_YearRas
     { dtb:=UserDeskRep.ResDate[1]
     }
     else
     { dtb:=date(1,w_MesRas,w_YearRas)
     }
     day_b:=day(dtb); day_e:=day(dte);
     mylogwrite(false,'=========Дата == '+Datetostr(dtb,'DD/MM/YYYY')
        +'-'+Datetostr(dte,'DD/MM/YYYY')
        +','+string(day_b)+','+string(day_e))
     if not SborData then exit;
     if month(ww_dt)=month(UserDeskRep.ResDate[2]) and year(UserDeskRep.ResDate[2])=year(ww_dt)
     { break
     }
     ww_dt:=add_months(ww_dt,1)
     
   } while true;
   if not inextVisual('Подсчет итогов') then exit;
   external _loop Tobot
   {  if not nextvisual then exit;
      ww_su:=Calc_Neyavki1
      
      
      //Tobot.Sum[42]:=ww_su+Tobot.Sum[41]+Calc_yavki1
       ;
      Tobot.Sum[6]:=Tobot.Sum[6]//ВЫХОДНЫЕ ДНИ ВХОДЯТ +Tobot.Sum[7]
      Tobot.Sum[9]:=Tobot.Sum[9]+Tobot.Sum[10]+Tobot.Sum[11]+Tobot.Sum[12]//Отпуск			
      Tobot.Sum[17]:=Tobot.Sum[17]+Tobot.Sum[18]+Tobot.Sum[19] //Дни нетрудоспособности		

      Tobot.Sum[8]:=Tobot.Sum[8]+Tobot.Sum[ 9]+Tobot.Sum[13]
                                +Tobot.Sum[14]+Tobot.Sum[15]
                                +Tobot.Sum[16]+Tobot.Sum[17]
                                +Tobot.Sum[20]
                                
      Tobot.Sum[21]:=Tobot.Sum[21]+Tobot.Sum[22]+Tobot.Sum[23]
                    +Tobot.Sum[24]+Tobot.Sum[25]+Tobot.Sum[26]
      Tobot.Sum[27]:=Tobot.Sum[28]+Tobot.Sum[29]+Tobot.Sum[30]
      //Календарный фонд времени
      Tobot.Sum[4]:=Tobot.Sum[6]+Tobot.Sum[8]+Tobot.Sum[21]
      Tobot.Sum[5]:=Tobot.Sum[4]- //=D18-(G18+J18+K18+P18)
          (Tobot.Sum[7]+Tobot.Sum[10]+Tobot.Sum[11]+Tobot.Sum[16])
      
       //среднесписочное
       if ww_lev_mes=0
       { Tobot.Sum[3]:=(Tobot.Sum[4])/CalcDaysBetweenDates(UserDeskRep.ResDate[1],UserDeskRep.ResDate[2],false)
       }
       else
       { if getfirst TMPKATALOG where (( ToBot.cut[ww_lev_mes] == TMPKATALOG.Nrec ))=0 
         { wexcol:=word(trim(substr(TMPKATALOG.NAME,pos('==',TMPKATALOG.NAME)+2,3) ) );
           Tobot.Sum[3]:=(Tobot.Sum[4])/Last_day(date(1,wexcol,year(UserDeskRep.ResDate[2])))
         }
       }
      update current Tobot;
      MyLogWrite(false,'Tobot.name='+tobot.NAMEGROUP+','+string(tobot.sum[3])
        +','+string(ToBot.cut[1])+'/'+string(ToBot.cut[2])+','+ToBot.cut[3]
        +','+string(ToBot.cut[4])+'/'+string(ToBot.cut[5])+','+ToBot.cut[6]
        )
   };
   // Построить дерево

   if not inextVisual('Построение дерева') then exit;
   
   /*
      // Задание параметров уровня группировки
      procedure TuneLevel( _Level     : tLevel;
                           _coTable   : word;    // Код таблицы (словарный)
                           _TabProp   : longint; // Параметры уровня
                           _TabPrefix : string;  // Префикс уровня
                           _TabCode   : word;    // Код разворачиваемой иерархии
                           _TabSort   : longint; // Код сортировки
                           _ExpCount  : word);   // Количество разворотов уровня
      //------------------------------------------------------------------------
        for (i:=1; i<=LevelCount; i:=i+1)
   {
     Param := 0;
     
     if (mHierar[i] = 0)
       Param := Param or tsNoExpand;
     
     if (mPrefix[i] = '')
       Param := Param or tsNoPrefix;
     
     if ( mKodKau[i] <> word(0) )
       Param := Param Or TuneKAULevel( cTree, i, mKodKau[i] )

     if (mName[i] > 0)
       TuneStructName( cTree, i, mName[i] );

     if not TuneLevel(cTree, i, mTable[i], Param, mPrefix[i],
                             kod, mGrupSort[i], mKol[i])
       exit;
   }

    */
   DoneWorkingTable;  
   if UserDeskRep.ResWord[39]<>7
   {

     cRep := InitTreeBuilder(#Tobot);
     if cRep=0 { message('Ошибка инициализации дерева!'); exit; }
     for(i:=1;i<=Grp_Count;i:=i+1)
     { 

    //TuneLevel(pTree, GetLevel(cgGrpKau1),   0,        KauParam,                  ''       ,1 ,0            ,0);
       TuneLevel(cRep, i                  , mTable[i] , if(mkol[i]=0,tsNoExpand,0), mName[i],0 , mGrupSort[i], mkol[i]);
     
       for(j:=1;j<=30;j++)
       {  TuneSum(cRep, j, 0, 0);
       }
       Mylogwrite(false,'Группировки '+string(mTable[i])+','+mName[i]+','+string(mkol[i])+','+string(mIeSvertka[Len1]))
     }
     SetReportStyles(cRep, rsNodeReport+if(logfilekl,rsShowStat,0), '  Всего') //UserDeskRep.RepName)
     BuildTunedTree(crep, CurCode); 
   
     if (cRep<>0)
       DoneTreeBuilder(cRep);
     if (UserDeskRep.ResWord[40] and 16)>0  
       and UserDeskRep.ResWord[41]>0 
       and UserDeskRep.ResWord[41]<6
     { 
       update TEMPDESCR where (( CurCode == TEMPDESCR.CODE )) set TEMPDESCR.CODE:=CurCode+1;
       update TOBOT where (( CurCode == TOBOT.CODE ))
         set   ToBot.cut[1]:=ToBot.cut[UserDeskRep.ResWord[41]]
            ,Tobot.Group[1]:=Tobot.Group[UserDeskRep.ResWord[41]]
            ,ToBot.cut[2]:=0,Tobot.Group[2]:=0
            ,ToBot.cut[3]:=0,Tobot.Group[3]:=0
            ,ToBot.cut[4]:=0,Tobot.Group[4]:=0
            ,ToBot.cut[5]:=0,Tobot.Group[5]:=0
            ;
    
       cRep := InitTreeBuilder(#Tobot);
       TuneLevel(cRep, 1
          , mTable[UserDeskRep.ResWord[41]], if(mkol[UserDeskRep.ResWord[41]]=0,tsNoExpand,0)
          , mName[UserDeskRep.ResWord[41]],0 , mGrupSort[UserDeskRep.ResWord[41]], mkol[UserDeskRep.ResWord[41]]);
     /*     
     TuneLevel(cRep, 1                  , 0 
       , tsSwitchTable //if(mkol[i]=0,tsNoExpand,0)
       , mName[UserDeskRep.ResWord[41]]
       ,0 
       , mGrupSort[UserDeskRep.ResWord[41]]
       , mkol[UserDeskRep.ResWord[41]]
       );
     */
       for(j:=1;j<=30;j++)
       {  TuneSum(cRep, j, 0, 0);
       }
       SetReportStyles(cRep, if(logfilekl,rsShowStat,0), UserDeskRep.RepName)
       BuildTunedTree(crep, CurCode);
       ww_nrec:=0
       if getfirst TEMPDESCR where 
         (( CurCode+1 == TEMPDESCR.CODE and 0 == TEMPDESCR.CGROUP  ))=0  
       {     ww_nrec:=TEMPDESCR.NREC;
         //message(' Nrec 0 уровня = '+string(ww_nrec) )
       }
       if getfirst  TEMPDESCR where 
         (( CurCode == TEMPDESCR.CODE and 0 == TEMPDESCR.CGROUP  ))=0
       { //message(TEMPDESCR.SORTNAME)
       }   
       update TEMPDESCR where 
         (( CurCode == TEMPDESCR.CODE and 0 == TEMPDESCR.CGROUP  )) 
         set TEMPDESCR.SORTNAME:=' '+TEMPDESCR.SORTNAME , TEMPDESCR.CGROUP:=ww_nrec;
       insert into TEMPDESCR set 
                  TEMPDESCR.CODE:=CurCode
                 ,TEMPDESCR.sortname:=chr(39)+' в том числе'
                 ,TEMPDESCR.name:='в том числе'
                 ,TEMPDESCR.isleaf:=0
                ; 
       ww_nrec1:=TEMPDESCR.Nrec
       update TEMPDESCR where 
         (( CurCode+1 == TEMPDESCR.CODE and ww_nrec == TEMPDESCR.CGROUP  )) 
           set TEMPDESCR.cGROUP:=0,TEMPDESCR.SORTNAME:='Я'+TEMPDESCR.SORTNAME ;          
       update TEMPDESCR where 
         (( CurCode+1 == TEMPDESCR.CODE )) set  TEMPDESCR.CODE:=CurCode;      

     } //if (UserDeskRep.ResWord[40] and 16)>0  
   } //   if UserDeskRep.ResWord[39]=7
  
   StopVisual('',0)  
   TreeGetFirstEx(MainTree );
   case UserDeskRep.ResWord[39] of  
   0: RunWindowModal(wnReport) ;
   end; 
   CreateReport:=true;
   rescanpanel(#UserDeskRep)
} //Function CreateReport :boolean;
//=================================
Function Report_Init(ww_tp:word) :boolean ;
{ Report_Init:=false;
  ClearTable(7901);  
  ClearTable(7902);
  type_report:=ww_tp;
  MainTree:=trTmpTree;
}
//===============================
Function Report_AddRow :boolean ;
{ Report_AddRow:=true;
}

//===============================
Function Report_Build(ww_tp:word) :boolean ;
var i,j :word;
  ww_ie:word;
{ if type_report=101  // табель Т-13
  { if ww_tp=2
    { update all tobot set ToBot.cut[1]:=ToBot.cut[2]
            ,Tobot.Group[1]:=Tobot.Group[2]
            ,ToBot.cut[2]:=0,Tobot.Group[2]:=0;
    
    }
    ResetBounds(#TempDescr)
    if getfirst TempDescr=0 {}
    delete TempDescr where (( 7901 == TempDescr.code ));
    if getfirst TempDescr=0 {}
    delete TempDescr where (( 7901 == TempDescr.code ));
    if getfirst TempDescr=0 {}
    setBounds(#TempDescr)

    cRep := InitTreeBuilder(#Tobot);

    if not ReadMyDsk(ww_ie,'FT02_ie_analitik',false) ww_ie:=0
    if cRep=0 { message('Ошибка инициализации дерева!'); exit; }
    if ww_tp=2
    { TuneLevel(cRep, 1, coTmpKatalog, 0, 'Аналитика:' ,7901, 0, ww_ie);
    }
    else
    { TuneLevel(cRep, 1, coKlKatego, tsNoExpand, 'Категория:' , 7901,0, 0);
      TuneLevel(cRep, 2, coTmpKatalog, 0, 'Аналитика:' , 7901,0, ww_ie);
    }  
    for(j:=1;j<=60;j++)  TuneSum(cRep, j, 0, 0);
    SetReportStyles(cRep, rsNodeReport+if(logfilekl,rsShowStat,0), 'Итого по табелю')
    BuildTunedTree(crep, 7901); 
    if (cRep<>0)
     DoneTreeBuilder(cRep);
 
  }//if type_report=101

  Report_Build:=true;
}
//===============================
Function Report_First(ww_tp:word) :integer ;
{ CurCode:=7901;
  Report_First:=if(TreeGetFirstEx(MainTree),if(TreeIsTerminal(MainTree),1,0),-1);
  
}
//===============================
Function Report_Next :integer ;
{ Report_Next:= if(TreeGetNextEx(MainTree),if(TreeIsTerminal(MainTree),1,0),-1);
}
//===============================
Function Report_Level :longint ;
{ Report_Level:= TreeLevel(MainTree);
}
//===============================
Function Report_GetValue(ww_column:word) :string ;
{ Report_GetValue:=''
  if ww_column=0 or ww_column>62 then exit;
  case ww_column of
  1 : Report_GetValue:=TempDescr.Name;
  62: Report_GetValue:=TempDescr.SortName;
  else
  {  Report_GetValue:=trim(String(TempDescr.Sum[ww_column-1],0,2))
     mylogwrite(false,'Report_GetValue '+string(ww_column)+'/'+Report_GetValue);
  }
  end;
}  //Function Report_GetValue(ww_column:word) :string ;
Function Report_GetValueD(ww_column:word) :double ;
{ Report_GetValueD:=0;
  if ww_column=0 or ww_column>62 then exit;
  case ww_column of
  1 : {}
  62: {}
  else
  {  Report_GetValueD:=TempDescr.Sum[ww_column-1]
     mylogwrite(false,'Report_GetValueD '+string(ww_column)+'/'+string(Report_GetValueD));
  }
  end;
}
//===============================

/*
   if ( not boIsTerm OR (wPrevLevel > wCurLevel) )
        {
          if ( boPrintHierGrp )
            {
              if ( (wPrevLevel <= wCurLevel) and (wCurLevel > 0) )
                {
                  // движение вглубь по иерархии, требуется сохранение позиции таблицы в стеке...
                  PushPos(#TempDescr);
                  inc(wPushCnt);
                }
              else
                {
                  //произошел переход по иерархии назад -> печать итоговых сумм для иерархического дерева
                  PrintTotal(wPrevLevel, wCurLevel, wPushCnt);

                  // сохраняем позицию того уровня на который был произведен переход, если это нетерминальная вершина...
                  if ( not boIsTerm )
                    {
                      PushPos(#TempDescr);
                      inc(wPushCnt);
                    }
                } //if

              if ( not boIsTerm )
                {
                  if (toc = 0)
                    {
                      //вывод заголовка иерархии
                      frmKSoprReestr.PutEventById(feDoLoop, fcGroupHeader_KS);
                      frmKSoprReestr.write(LPadCh('', ' ', wCurLevel) +  TempDescr.Name);

                      frmKSoprReestr.write(TempDescr.Sum[1], 2); //GroupSum2
                      frmKSoprReestr.write(TempDescr.Sum[2], 2); //GroupSumV2

                      // PercentNDE
                      if ((wPrintForm = 0) and (abs(dblReestrTotalNDE) > 0.000000000001))
                        frmKSoprReestr.write(((TempDescr.Sum[1] / dblReestrTotalNDE) * 100), 2)
                      else
                        frmKSoprReestr.SkipFormat(1);
                    }
                  else
                    {
                      pXL.ClearTblBuffer;
                      summm3 := (TempDescr.Sum[1] / dblReestrTotalNDE) * 100;
                      pXL.SetTblStringFldValue('nn0a',LPadCh('', ' ', wCurLevel ) +  TempDescr.Name);
                      pXL.InsTblRow;
                    }

                }
            }
        }

*/