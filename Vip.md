# ВНИМАНИЕ! Существует особенность в построении условий на Логическую таблицу #

Если условие налагается на одно поле, по которому нет односегментного индекса, то в логической таблице будут агрегированы поля из второго поля Индекса с учётом условия.

Пример: необходимо получить количество MBPin без привязки к Документу
```
Select MBPin.nRec where (( 0 == MBPin.cSopr )) ;
```
такой запрос выдаст результат, НО!!! будут выданы все записи MBPin с нулевой ссылкой cSopr, а затем сагрегированы по полю OrdDoc, т.к. одиночного индекса cSopr в таблице MBPin нет, а есть лишь индекс cSopr+OrdDoc

Такая особенность проявляется как в запросах Support, так и в vip-интерфейсах.

Примечание: ПИР №180.6863 для вывода всех записей MBPin по вышеописанному усливию необходимо сделать следующий запрос:
```
Select MBPin.nRec where ( 0 = MBPin.cSopr ) ;
```

# Delete All #

Следует иметь в виду, что при использовании конструкции "Delete all" для неКорневой таблицы будут удалены лишь записи, попадающие в текущие ограничения - т.е. не все записи из обрабатываемой табилцы


# nRec для Oracle #

```
#include epSystem.vih

//**********************************************************
#component ""
handler with replace RegisterGlobToOraComp on extensionPoint epAppInit
action
{
  RegisterGlobalIfc('ToOraCompIfc');
  result := true;
}

//**********************************************************

vipInterface ToOraCompIfc;
  static: function oRec(inComp : variant): string;
end;

//**********************************************************

interface ToOraCompIfc;
//----------------------------------------------------------

function oRec(inComp : variant): string;
var str:string;
{
 str := string(inComp,0,0);
 if MatchesMask(str, '[0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F][0~9A~F]h')
 {

  result := BCase(str[1] = '0': '8',
                  str[1] = '1': '9',
                  str[1] = '2': 'A',
                  str[1] = '3': 'B',
                  str[1] = '4': 'C',
                  str[1] = '5': 'D',
                  str[1] = '6': 'E',
                  str[1] = '7': 'F',
                  str[1] = '8': '0',
                  str[1] = '9': '1',
                  str[1] = 'A': '2',
                  str[1] = 'B': '3',
                  str[1] = 'C': '4',
                  str[1] = 'D': '5',
                  str[1] = 'E': '6',
                  str[1] = 'F': '7';
                   'Это бы не нрек!!! ') + substr(str,2,15)
 }
  else result := 'Давай нрек на вход!!!!';
}
end.
```